{"version":3,"sources":["pm.js"],"names":["hasYarn","_hasYarn","startingPath","useCached","p","path","normalize","length","yarnLock","resolve","file","join","fs","accessSync","e","parsed","parse","root","dir"],"mappings":"AAEA;;;;;QAgBgBA,O,GAAAA,O;;AAdhB;;;;AACA;;;;;;AAEA;;;;;;;;;;AAUA,IAAIC,iBAAJ;AACO,SAASD,OAAT,CAAiBE,YAAjB,EAA2E;AAAA,MAApCC,SAAoC,uEAAf,IAAe;;AAChF,MAAIF,YAAY,IAAZ,IAAoBE,SAAxB,EAAmC;AACjC,WAAOF,QAAP;AACD;;AAEDA,aAAW,KAAX;AACA,MAAIG,IAAIC,eAAKC,SAAL,CAAeJ,YAAf,CAAR;AACA,SAAOE,EAAEG,MAAF,GAAW,CAAlB,EAAqB;AACnB,QAAMC,WAAWH,eAAKI,OAAL,CAAaL,CAAb,EAAgB,WAAhB,CAAjB;AACA,QAAI;AACF,UAAMM,OAAOL,eAAKM,IAAL,CAAUP,CAAV,EAAa,WAAb,CAAb;AACAQ,mBAAGC,UAAH,CAAcH,IAAd;AACAT,iBAAW,IAAX;AACA;AACD,KALD,CAKE,OAAOa,CAAP,EAAU;AACV,UAAMC,SAASV,eAAKW,KAAL,CAAWZ,CAAX,CAAf;AACA,UAAIW,OAAOE,IAAP,KAAgBF,OAAOG,GAA3B,EAAgC;AAC9B;AACD;AACDd,UAAIW,OAAOG,GAAX;AACD;AACF;AACD,SAAOjB,QAAP;AACD","file":"pm.js","sourcesContent":["// @flow\n\n'use strict';\n\nimport path from 'path';\nimport fs from 'fs';\n\n/**\n * check if the current path uses yarn, i.e. looking for yarn.lock in\n * the current path and up\n *  \n * @param {*} startingPath a path where we will look for yarn.lock file. \n * Will traverse up the filesystem until we either find the file or reach the root\n * \n * @param {boolean} useCached if true and we have a cached hasYarn result, it will be returned, otherwise go through the\n * normal lookup logic described above. mainly for optimization purpose, default is true.\n */\nlet _hasYarn: ?boolean;\nexport function hasYarn(startingPath: string, useCached: boolean = true): boolean {\n  if (_hasYarn != null && useCached) {\n    return _hasYarn;\n  }\n\n  _hasYarn = false;\n  let p = path.normalize(startingPath);\n  while (p.length > 0) {\n    const yarnLock = path.resolve(p, 'yarn.lock');\n    try {\n      const file = path.join(p, 'yarn.lock');\n      fs.accessSync(file);\n      _hasYarn = true;\n      break;\n    } catch (e) {\n      const parsed = path.parse(p);\n      if (parsed.root === parsed.dir) {\n        break;\n      }\n      p = parsed.dir;\n    }\n  }\n  return _hasYarn;\n}\n"]}